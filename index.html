<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  
  <!-- PWA Settings -->
  <meta name="theme-color" content="#000000">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="Timer">
  <link rel="manifest" id="manifest-placeholder">
  
  <!-- Custom SVG Icon -->
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Ccircle cx='32' cy='32' r='30' fill='%23222' stroke='%23fff' stroke-width='4'/%3E%3Cpath d='M32 6 V14 M32 50 V58 M6 32 H14 M50 32 H58' stroke='%23888' stroke-width='3' stroke-linecap='round'/%3E%3Cline x1='32' y1='32' x2='32' y2='16' stroke='%23ff0000' stroke-width='3' stroke-linecap='round'/%3E%3Cline x1='32' y1='32' x2='46' y2='32' stroke='%23fff' stroke-width='3' stroke-linecap='round'/%3E%3C/svg%3E">
  <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' fill='%23000'/%3E%3Ccircle cx='32' cy='32' r='28' fill='%23222' stroke='%23fff' stroke-width='4'/%3E%3Cpath d='M32 8 V16 M32 48 V56 M8 32 H16 M48 32 H56' stroke='%23888' stroke-width='3' stroke-linecap='round'/%3E%3Cline x1='32' y1='32' x2='32' y2='16' stroke='%23ff0000' stroke-width='3' stroke-linecap='round'/%3E%3Cline x1='32' y1='32' x2='46' y2='32' stroke='%23fff' stroke-width='3' stroke-linecap='round'/%3E%3C/svg%3E">

  <title>Presentation Timer</title>
  <style>
    :root {
      --bg-color: #000000;
      --text-color-default: #ffffff;
      --text-color-paused: #666666;
      --text-color-bell1: #ffff00;
      --text-color-bell2: #ff8c00;
      --text-color-bell3: #ff0000;
      --control-bg: rgba(50, 50, 50, 0.9); /* Slightly darker for better contrast */
    }

    body {
      margin: 0;
      padding: 0;
      background-color: var(--bg-color);
      color: var(--text-color-default);
      font-family: 'Helvetica Neue', Arial, sans-serif;
      height: 100vh;
      width: 100vw;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      transition: color 0.3s ease;
      -webkit-tap-highlight-color: transparent; /* Remove tap highlight on mobile */
    }

    /* Timer Display */
    #timer-display {
      font-size: min(34vw, 60vh);
      font-weight: bold;
      font-family: 'Menlo', 'Consolas', 'Monaco', 'Liberation Mono', 'Lucida Console', monospace;
      font-variant-numeric: tabular-nums;
      line-height: 1;
      cursor: default;
      user-select: none;
      white-space: nowrap;
    }

    /* Controls Overlay */
    #controls-container {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background-color: var(--control-bg);
      padding: 10px 0;
      padding-bottom: env(safe-area-inset-bottom, 10px); /* Handle iPhone notch/home bar */
      display: flex;
      justify-content: center;
      gap: 15px;
      transform: translateY(90%);
      transition: transform 0.3s ease-out, opacity 0.3s;
      opacity: 0.3;
      z-index: 10;
    }

    #controls-container:hover,
    #controls-container.active {
      transform: translateY(0);
      opacity: 1;
    }

    button {
      font-size: 1.2rem;
      padding: 12px 24px; /* Larger touch target */
      cursor: pointer;
      background: #444;
      color: #fff;
      border: 1px solid #666;
      border-radius: 4px;
      touch-action: manipulation; /* Disable double-tap zoom */
    }

    button:hover {
      background: #666;
    }

    button:active {
      background: #888;
    }

    /* Settings Modal */
    #settings-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      justify-content: center;
      align-items: center;
      z-index: 100;
    }

    .settings-content {
      background: #222;
      padding: 30px;
      border-radius: 8px;
      width: 90%;
      max-width: 600px;
      color: #fff;
      max-height: 90vh;
      overflow-y: auto;
    }

    .settings-group {
      margin-bottom: 15px;
      display: flex;
      flex-direction: column;
    }

    .settings-group label {
      margin-bottom: 5px;
      font-size: 0.9rem;
      color: #ccc;
    }
    
    .time-input-group {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .time-input-group input {
      width: 80px;
      padding: 8px;
      font-size: 1rem;
      background: #333;
      border: 1px solid #555;
      color: #fff;
      text-align: right;
    }

    .time-input-group span {
      margin-right: 10px;
    }

    select {
      padding: 8px;
      font-size: 1rem;
      background: #333;
      border: 1px solid #555;
      color: #fff;
    }

    .close-btn {
      background: #d32f2f;
      border-color: #b71c1c;
      width: 100%;
      margin-top: 20px;
    }
    
    .hint {
      font-size: 0.8rem;
      color: #aaa;
      margin-top: 5px;
    }

    /* Color States */
    body.state-paused { color: var(--text-color-paused) !important; }
    body.state-bell1 { color: var(--text-color-bell1); }
    body.state-bell2 { color: var(--text-color-bell2); }
    body.state-bell3 { color: var(--text-color-bell3); }

  </style>
</head>
<body>

  <div id="timer-display">00:00</div>

  <!-- Controls -->
  <div id="controls-container">
    <button id="btn-start">スタート</button>
    <button id="btn-pause">一時停止</button>
    <button id="btn-reset">リセット</button>
    <button id="btn-settings">設定</button>
  </div>

  <!-- Settings Modal -->
  <div id="settings-modal">
    <div class="settings-content">
      <h2>設定</h2>
      
      <div class="settings-group">
        <label>モード</label>
        <select id="input-mode">
          <option value="up">カウントアップ</option>
          <option value="down">カウントダウン</option>
        </select>
        <div class="hint">※カウントダウンの開始時間は、各鈴の中で最も遅い時間に自動設定されます。</div>
      </div>

      <div class="settings-group">
        <label>第1鈴 (黄色)</label>
        <div class="time-input-group">
          <input type="number" id="input-bell1-min" value="10" min="0"> <span>分</span>
          <input type="number" id="input-bell1-sec" value="0" min="0" max="59"> <span>秒</span>
        </div>
      </div>

      <div class="settings-group">
        <label>第2鈴 (橙色)</label>
        <div class="time-input-group">
          <input type="number" id="input-bell2-min" value="15" min="0"> <span>分</span>
          <input type="number" id="input-bell2-sec" value="0" min="0" max="59"> <span>秒</span>
        </div>
      </div>

      <div class="settings-group">
        <label>第3鈴 (赤色)</label>
        <div class="time-input-group">
          <input type="number" id="input-bell3-min" value="20" min="0"> <span>分</span>
          <input type="number" id="input-bell3-sec" value="0" min="0" max="59"> <span>秒</span>
        </div>
      </div>

      <div class="settings-group">
        <button id="btn-test-sound">音テスト (1回)</button>
      </div>

      <button class="close-btn" id="btn-close-settings">設定終了</button>
    </div>
  </div>

  <script>
    /**
     * PWA Injection (Manifest)
     * Use Data URI (Base64) for better compatibility on Android
     */
    (function setupPWA() {
      const iconUrl = document.querySelector('link[rel="icon"]').href;
      const manifest = {
        "name": "Presentation Timer",
        "short_name": "Timer",
        "start_url": ".",
        "display": "standalone",
        "background_color": "#000000",
        "theme_color": "#000000",
        "orientation": "any",
        "icons": [
          { "src": iconUrl, "sizes": "192x192", "type": "image/svg+xml" },
          { "src": iconUrl, "sizes": "512x512", "type": "image/svg+xml" }
        ]
      };
      
      // Use Base64 Data URI to avoid Blob URL issues on Android Chrome
      const stringManifest = JSON.stringify(manifest);
      const blobManifest = new Blob([stringManifest], {type: 'application/manifest+json'});
      const reader = new FileReader();
      reader.onload = function(e) {
          document.getElementById('manifest-placeholder').setAttribute('href', e.target.result);
      };
      reader.readAsDataURL(blobManifest);
    })();

    /**
     * Timer Logic
     */
    class PresentationTimer {
      constructor() {
        this.config = {
          mode: 'up',
          bell1Sec: 600,
          bell2Sec: 900,
          bell3Sec: 1200
        };
        this.startTime = 0;
        this.elapsedTime = 0;
        this.isRunning = false;
        this.animationFrameId = null;
        this.lastBellState = 0;
        this.audioCtx = null;

        this.elTimer = document.getElementById('timer-display');
        this.elBody = document.body;
        this.modal = document.getElementById('settings-modal');
        
        this.init();
      }

      init() {
        this.loadUrlParams();
        this.bindEvents();
        this.updateDisplay(0);
        this.applyConfigToInputs();
        this.elBody.classList.add('state-paused');
      }

      loadUrlParams() {
        const params = new URLSearchParams(window.location.search);
        if (params.has('mode')) this.config.mode = params.get('mode');
        
        const parseParam = (key, defaultSec) => {
            if (params.has(key + 's')) return parseInt(params.get(key + 's'), 10);
            if (params.has(key)) {
                const val = params.get(key);
                if (val.includes(':')) {
                    const parts = val.split(':');
                    return (parseInt(parts[0], 10) || 0) * 60 + (parseInt(parts[1], 10) || 0);
                }
                return parseFloat(val) * 60;
            }
            return defaultSec;
        };

        this.config.bell1Sec = parseParam('b1', this.config.bell1Sec);
        this.config.bell2Sec = parseParam('b2', this.config.bell2Sec);
        this.config.bell3Sec = parseParam('b3', this.config.bell3Sec);
      }

      bindEvents() {
        // Helper to bind both click and touchend for robust mobile response
        const bindBtn = (id, handler) => {
            const btn = document.getElementById(id);
            // Standard click
            btn.addEventListener('click', (e) => {
                handler(e);
            });
            // Touch end (fixes issue where moving UI elements cancel clicks on Android)
            btn.addEventListener('touchend', (e) => {
                e.preventDefault(); // Prevent phantom click
                handler(e);
            });
        };

        bindBtn('btn-start', () => this.start());
        bindBtn('btn-pause', () => this.pause());
        bindBtn('btn-reset', () => this.reset());
        
        bindBtn('btn-settings', () => {
          this.modal.style.display = 'flex';
          this.applyConfigToInputs();
        });
        
        bindBtn('btn-close-settings', () => {
          this.saveInputsToConfig();
          this.modal.style.display = 'none';
          this.updateDisplay(this.elapsedTime);
        });
        
        bindBtn('btn-test-sound', () => {
          this.initAudioContext();
          this.playChime(1);
        });

        let hideTimeout;
        const controls = document.getElementById('controls-container');
        
        // Show controls logic
        const showControls = () => {
          controls.classList.add('active');
          clearTimeout(hideTimeout);
          hideTimeout = setTimeout(() => controls.classList.remove('active'), 3000);
        };
        
        window.addEventListener('mousemove', showControls);
        // Use passive listener for scrolling performance, though we don't scroll much
        window.addEventListener('touchstart', showControls, {passive: true});
      }

      initAudioContext() {
        if (!this.audioCtx) {
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          this.audioCtx = new AudioContext();
        }
        if (this.audioCtx.state === 'suspended') {
          this.audioCtx.resume();
        }
      }

      start() {
        if (this.isRunning) return;
        this.initAudioContext();
        this.startTime = Date.now() - this.elapsedTime;
        this.isRunning = true;
        this.elBody.classList.remove('state-paused');
        this.loop();
      }

      pause() {
        this.isRunning = false;
        this.elBody.classList.add('state-paused');
        cancelAnimationFrame(this.animationFrameId);
      }

      reset() {
        this.pause();
        this.elapsedTime = 0;
        this.lastBellState = 0;
        this.updateDisplay(0);
        this.setBellState(0);
        this.elBody.classList.add('state-paused');
      }

      loop() {
        if (!this.isRunning) return;
        this.elapsedTime = Date.now() - this.startTime;
        this.updateDisplay(this.elapsedTime);
        this.checkBells(this.elapsedTime);
        this.animationFrameId = requestAnimationFrame(() => this.loop());
      }

      updateDisplay(ms) {
        let totalSeconds;
        if (this.config.mode === 'down') {
          const maxSec = Math.max(this.config.bell1Sec, this.config.bell2Sec, this.config.bell3Sec);
          let remainingMs = (maxSec * 1000) - ms;
          if (remainingMs < 0) remainingMs = 0;
          totalSeconds = Math.ceil(remainingMs / 1000);
        } else {
          totalSeconds = Math.floor(ms / 1000);
        }
        
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        const strMin = String(minutes).padStart(2, '0');
        const strSec = String(seconds).padStart(2, '0');

        this.elTimer.textContent = `${strMin}:${strSec}`;
      }

      checkBells(elapsedMs) {
        const elapsedSec = elapsedMs / 1000;
        let currentState = 0;

        if (elapsedSec >= this.config.bell3Sec) currentState = 3;
        else if (elapsedSec >= this.config.bell2Sec) currentState = 2;
        else if (elapsedSec >= this.config.bell1Sec) currentState = 1;

        if (currentState > this.lastBellState) {
          this.playChime(currentState);
          this.lastBellState = currentState;
        }
        this.setBellState(currentState);
      }

      setBellState(state) {
        this.elBody.classList.remove('state-bell1', 'state-bell2', 'state-bell3');
        if (state === 1) this.elBody.classList.add('state-bell1');
        if (state === 2) this.elBody.classList.add('state-bell2');
        if (state === 3) this.elBody.classList.add('state-bell3');
      }

      playChime(count) {
        if (!this.audioCtx) return;
        const now = this.audioCtx.currentTime;
        const interval = 0.4;
        for (let i = 0; i < count; i++) {
          this.playTone(now + (i * interval));
        }
      }

      playTone(startTime) {
        const fundamental = 6600; 
        const duration = 2;
        const createOsc = (ratio, gainVal, decayTime) => {
          const osc = this.audioCtx.createOscillator();
          const gain = this.audioCtx.createGain();
          osc.connect(gain);
          gain.connect(this.audioCtx.destination);
          osc.type = 'sine';
          osc.frequency.value = fundamental * ratio;
          gain.gain.setValueAtTime(0, startTime);
          gain.gain.linearRampToValueAtTime(gainVal, startTime + 0.005);
          gain.gain.exponentialRampToValueAtTime(0.001, startTime + decayTime);
          osc.start(startTime);
          osc.stop(startTime + decayTime);
        };
        createOsc(1.0, 0.6, duration);
        createOsc(0.58, 0.2, duration * 0.7); 
        createOsc(2.1, 0.15, duration * 0.6);
        createOsc(3.4, 0.05, duration * 0.4);
        createOsc(4.8, 0.05, 0.3);
      }
      
      applyConfigToInputs() {
        document.getElementById('input-mode').value = this.config.mode;
        this.setMmSsInputs('bell1', this.config.bell1Sec);
        this.setMmSsInputs('bell2', this.config.bell2Sec);
        this.setMmSsInputs('bell3', this.config.bell3Sec);
      }

      setMmSsInputs(idPrefix, totalSeconds) {
        const m = Math.floor(totalSeconds / 60);
        const s = Math.floor(totalSeconds % 60);
        document.getElementById(`input-${idPrefix}-min`).value = m;
        document.getElementById(`input-${idPrefix}-sec`).value = s;
      }

      saveInputsToConfig() {
        this.config.mode = document.getElementById('input-mode').value;
        this.config.bell1Sec = this.getSecondsFromInput('bell1');
        this.config.bell2Sec = this.getSecondsFromInput('bell2');
        this.config.bell3Sec = this.getSecondsFromInput('bell3');
        this.checkBells(this.elapsedTime);
      }

      getSecondsFromInput(idPrefix) {
        const m = parseInt(document.getElementById(`input-${idPrefix}-min`).value) || 0;
        const s = parseInt(document.getElementById(`input-${idPrefix}-sec`).value) || 0;
        return (m * 60) + s;
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      new PresentationTimer();
    });
  </script>
</body>
</html>
